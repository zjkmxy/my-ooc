/*9:1*/

/*
 * 协变和逆变是类型系统中一个较为复杂的话题，
 * 对于静态类型系统来说，只有为数不多的几个支持这种变化；
 * 对于动态类型系统来说，协变和逆变往往并不需要显式地给出，
 * 而只需要它们“在事实上是成立的”。
 * 在引入协变和逆变之前，我们先引入几个并不相关的OO概念。
 *
 * 1.鸭子类型系统(duck-typing)
 * 名字来源于“能嘎嘎叫的就是鸭子”。亦即在动态类型系统中，我们
 * 不在运行时人为检查量的类型，而是直接看目标有没有对应的槽；
 * 比如有一个函数复杂打印整型的列表，它不去检查列表中的每个元素
 * 类型是否是Int，而是直接给它发Print消息，没有异常就算通过。
 * 这样在某种程度上拓展了函数的功能：所有有"Print"槽的对象列表，即使
 * 不是Int，也能直接被我们的函数打印了。
 * 如果在静态类型系统中做到这一点，我们需要人工地提取出一个IPrintable
 * 接口，然后修改涉及到的类型让它们实现这个接口。
 * 鸭子类型系统中并不存在人为声明的接口类型，而是把某个或某一组槽自动变成
 * 了一个接口，即为“事实上的”接口。
 *
 * 2.混入继承(mixin)
 * 因为有了鸭子类型系统，动态类型语言一般禁止多类继承。但是存在这样一种情况，即
 * 我们希望实现了某个接口的类共享某些成员函数。比如：实现了"<"槽的对象都有">"槽
 * 和"=="槽以及"!="槽，它们的实现也一样。就像Java8里接口的成员方法一样。
 * 在原型法中，我们可以用这样的方式：设计一个Compare对象，它的成员函数包括
 * ">","=="和"!="，它们通过某种方法获得消息的来源sender，设rhs表示比较的另一个对象
 * （参数），Compare的这些函数通过向sender发"<"消息，然后进行某种处理来获得结果；
 * 对于每个拥有"<"槽的类或对象，可以直接让其持有一个Compare对象，然后将自己的">"等
 * 消息直接转发给Compare即可。
 * 这种策略称为“混入”(mixin)。Ruby语言采用了类似的策略，不过和上述的表述略有差异。
 * Java8中带成员方法的接口可以看作是混入的一种。
 *
 * 3.类型适配的根本
 * 所有类型转化，不管是通过编程转化(静态类型)，还是事实上的转化(动态类型)，
 * 都建立在这样一个基础之上：提供方(out)提供了需求方(in)应有的所有槽。
 * 我们把B类型的值赋给A类型的变量时，A是需求方，B是提供方，所以B是A的子类；
 * 我们将B类型的值以A类型参数形式传递时，A是需求方，B是提供方，所以B是A的子类；
 * 我们将返回B类型的函数当作返回A类型的函数调用时，A是需求方，B是提供方，
 * 所以B是A的子类；
 * 以此类推，不管是赋值还是参数传递还是其他什么时候，out永远是in的子类。
 *
 * 4.协变(covariance)、逆变(contvariance)和不变(invariance)
 * （三个词应该是来源于张量代数）
 * 问题发生在模板存在的时候。
 * 假设函数printList负责打印List<IPrintable>列表中的元素，
 * 函数randInt给一个List<Int>型的列表添加若干随机元素，
 * 类型的继承关系是IPrintable->Number->Int，亦即所有整数都是数，所有数都可以打印。
 * 那么我们能否将randInt的返回值赋给List<Number>型变量var，
 * 然后将var传递给printList调用呢？
 *
 * 在静态类型语言中，答案是“不能”。因为对List<'a>来说，
 * 列表既可以添加元素add，也可以获取元素get，
 * 在add中'a是in类型，在get中'a是out类型；
 * 因此List<'a>中'a对List既是in又是out，根据out>=in的不等式得出
 * List<'a>可以转化成List<'b>当且仅当'a == 'b。
 *
 * 为了解决这个问题，C#允许我们将List的两个方法get和add拆分成两个模板接口
 * IGet<out 'a>和IAdd<in 'a>，IGet定义的所有方法中'a都是输出类型，IAdd中
 * 'a永远是输入类型。
 * 这样我们发现，printList需要的其实是IGet<IPrintable>，而randInt需要的是
 * IAdd<Int>。List<'a>同时实现了IGet<'a>和IAdd<'a>。
 * 在这种关系下，List<Number>可以转化为IGet<IPrintable>(协变)，也可以
 * 转化为IAdd<Int>(逆变，模板内部是从基类到子类的)。
 *
 * 规律如下：
 * 如果某一层<>为out，那么out对应的<...>内部的所有变化关系反转；
 * 如果某一层<>为in，那么in对应的<...>内部的所有变化关系不变；
 * 只要某一层<>是不变inout，其内部的in和out将全部被改写成inout；
 * 函数的只读参数为in，只写参数为out，读写参数强制不变；
 * 函数本身的类型为func:: A->B  => Func<in A, out B>；
 * 闭包和函数满足同一规则；
 *
 * 最后一句其实是这样的：
 * 比如说X是Y的基类，我们有个函数f::(X,X)->Y
 * 然后我们有个函数g(x1:X)是返回闭包(x2:X)->{return f(x1, x2);}
 * 闭包的类型是X->Y亦即Func<in X, out Y>
 * 函数g的类型是Func<in X, out Func<in X, out Y>>
 * 函数f的类型是Func<in X, in X, out Y>
 * 当我们需要一个(X,Y)->X型的函数时，我们可以用f，也可以用g。
 * 当用f时，是这样的匹配：<in X, in Y, out X> <= <in X, in X, out Y>
 * 当用g时是这样：<in X, out <in Y, out X>> <= <in X, out <in X, out Y>>
 * out里面的<in Y, out X>反转成了<out Y, in X>；
 */

#ifndef _CONS_H
#define _CONS_H

#include "system_export.h"
#include "integer.h"

/* 
 * 这里我们定义了一个广义表类，通过这个广义表类表现之前说过的例子
 * 不使用静态类型系统的理由是：静态类型系统实现协变逆变需要多接口继承+反射+不能类型擦除
 * 这个比较难写
 */

#define SYMBOL_CAR     41
#define SYMBOL_CDR     42
#define SYMBOL_RANDINT 43
#define SYMBOL_MAKE_LIST 44

extern Handle g_Cons;

void Cons_loadCons();

#endif
